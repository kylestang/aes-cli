#include <catch2/catch_test_macros.hpp>
#include <crypto/aes.hpp>
#include <crypto/crypto.hpp>

using namespace crypto;

TEST_CASE("Substitute bytes") {
    const Block input{
        0x01, 0xde, 0x45, 0x91, 0x88, 0xaa, 0x20, 0xfe,
        0x0f, 0x0a, 0x6b, 0x3d, 0xd3, 0x50, 0x00, 0xff,
    };

    const Block expected{
        0x7c, 0x1d, 0x6e, 0x81, 0xc4, 0xac, 0xb7, 0xbb,
        0x76, 0x67, 0x7f, 0x27, 0x66, 0x53, 0x63, 0x16,
    };

    const Block result = sub_bytes(input);

    REQUIRE(expected == result);
}

TEST_CASE("Shift rows") {
    const Block input{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const Block expected{
        0x0, 0x1, 0x2, 0x3, 0x5, 0x6, 0x7, 0x4,
        0xa, 0xb, 0x8, 0x9, 0xf, 0xc, 0xd, 0xe,
    };

    const Block result = shift_rows(input);

    REQUIRE(expected == result);
}

TEST_CASE("Mix columns") {
    const Block input{
        0xdb, 0xf2, 0x01, 0xc6, 0x13, 0x0a, 0x01, 0xc6,
        0x53, 0x22, 0x01, 0xc6, 0x45, 0x5c, 0x01, 0xc6,
    };

    const Block expected{
        0x8e, 0x9f, 0x01, 0xc6, 0x4d, 0xdc, 0x01, 0xc6,
        0xa1, 0x58, 0x01, 0xc6, 0xbc, 0x9d, 0x01, 0xc6,
    };

    const Block result = mix_columns(input);

    REQUIRE(expected == result);
}

TEST_CASE("Add round key") {
    const Block input{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const std::vector<uint8_t> key_bytes{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const AesKey key(key_bytes);

    SECTION("Round 0") {
        const Block expected = {
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        };

        const Block result = add_round_key(input, key, 0);

        REQUIRE(expected == result);
    }

    SECTION("Round 1") {
        const Block expected = {0xd6, 0xab, 0x76, 0xfe, 0xd6, 0xaa, 0x74, 0xfd,
                                0xd2, 0xaf, 0x72, 0xfa, 0xda, 0xa6, 0x78, 0xf1};

        const Block result = add_round_key(input, key, 1);

        REQUIRE(expected == result);
    }
}

TEST_CASE("Encrypt 128") {
    const Block input{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const std::vector<uint8_t> key_bytes{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const Block expected{
        0xa,  0x94, 0xb,  0xb5, 0x41, 0x6e, 0xf0, 0x45,
        0xf1, 0xc3, 0x94, 0x58, 0xc6, 0x53, 0xea, 0x5a,
    };

    const AesKey key(key_bytes);

    const Block result = encrypt(input, key);

    REQUIRE(expected == result);
}
