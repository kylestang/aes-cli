#include <catch2/catch_test_macros.hpp>
#include <crypto/aes.hpp>
#include <crypto/crypto.hpp>
#include <iostream>

using namespace crypto;

TEST_CASE("Substitute bytes") {
    const Block input{
        0x01, 0xde, 0x45, 0x91, 0x88, 0xaa, 0x20, 0xfe,
        0x0f, 0x0a, 0x6b, 0x3d, 0xd3, 0x50, 0x00, 0xff,
    };

    const Block expected{
        0x7c, 0x1d, 0x6e, 0x81, 0xc4, 0xac, 0xb7, 0xbb,
        0x76, 0x67, 0x7f, 0x27, 0x66, 0x53, 0x63, 0x16,
    };

    const Block result = sub_bytes(input);

    REQUIRE(expected == result);
}

TEST_CASE("Shift rows") {
    const Block input{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const Block expected{
        0x0, 0x1, 0x2, 0x3, 0x5, 0x6, 0x7, 0x4,
        0xa, 0xb, 0x8, 0x9, 0xf, 0xc, 0xd, 0xe,
    };

    const Block result = shift_rows(input);

    REQUIRE(expected == result);
}

TEST_CASE("Mix columns") {
    const Block input{
        0xdb, 0xf2, 0x01, 0xc6, 0x13, 0x0a, 0x01, 0xc6,
        0x53, 0x22, 0x01, 0xc6, 0x45, 0x5c, 0x01, 0xc6,
    };

    const Block expected{
        0x8e, 0x9f, 0x01, 0xc6, 0x4d, 0xdc, 0x01, 0xc6,
        0xa1, 0x58, 0x01, 0xc6, 0xbc, 0x9d, 0x01, 0xc6,
    };

    const Block result = mix_columns(input);

    REQUIRE(expected == result);
}

TEST_CASE("Add round key") {
    const Block input{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const std::vector<uint8_t> key_bytes{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const AesKey key(key_bytes);

    SECTION("Round 0") {
        const Block expected = {
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        };

        const Block result = add_round_key(input, key, 0);

        REQUIRE(expected == result);
    }

    SECTION("Round 1") {
        const Block expected = {0xd6, 0xab, 0x76, 0xfe, 0xd6, 0xaa, 0x74, 0xfd,
                                0xd2, 0xaf, 0x72, 0xfa, 0xda, 0xa6, 0x78, 0xf1};

        const Block result = add_round_key(input, key, 1);

        REQUIRE(expected == result);
    }
}

TEST_CASE("Encrypt 128") {
    const Block input{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const std::vector<uint8_t> key_bytes{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const Block expected{0xb6, 0x1e, 0x6a, 0xf8, 0xda, 0x72, 0x60, 0xd2,
                         0x21, 0x43, 0x69, 0xb9, 0x51, 0xbf, 0x89, 0x63};

    AesKey key(key_bytes);
    for (int i = 0; i < key.get_key().size(); i++) {
        std::cout << std::setfill('0') << std::setw(2) << std::hex
                  << (int)key.get_key()[i] << " ";
    }
    std::cout << "\n";

    const Block result = encrypt(input, key);

    REQUIRE((int)expected[0] == (int)result[0]);
    REQUIRE(expected == result);
}
/*
TEST_CASE("Encrypt and decrypt") {
    const Block plaintext{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };

    const std::vector<uint8_t> key_bytes{
        0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
        0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    };
    const AesKey key(key_bytes);

    const Block ciphertext = encrypt(plaintext, key);

    const Block result = decrypt(ciphertext, key);

    REQUIRE(plaintext == result);
}
*/
